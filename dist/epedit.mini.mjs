function u(o){let e=o;return e=e.replace(/[-/*()]/g,""),e=e.replace(/ /g,"_"),e}function S(o){return Object.fromEntries(Object.entries(o).map(([e,t])=>[u(e),t]))}function D(o,e,t,s){switch(o){case"int":typeof e=="string"?e=parseInt(e):e=Math.trunc(e);break;case"float":typeof e=="string"&&(e=parseFloat(e));break;case"string":e=String(e);break;default:throw new RangeError(`Type '${o}' not supported for ${t} - ${s}`)}return e}function E(o,e){let t=[],s=Math.max(o.length,e.length);for(let i=0;i<s;i++)i<o.length&&t.push(o[i]),i<e.length&&t.push(e[i]);return t}function y(o,e=/[ ]/){if(!o)return"";e=new RegExp(e.source,"g");let t=o.match(e)??[],s=o.toLowerCase().split(e).map(i=>i.charAt(0).toUpperCase()+i.slice(1));return E(s,t).join("")}function C(o){return o.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}var x=class{constructor(e="./idds"){this.iddCache={},e.endsWith("/")&&(e=e.slice(0,-1)),this.iddDir=e}async getVersion(e,t=!1){let s=e.match(/\d+[\-.]\d+/);if(s==null)throw new RangeError(`'${e}' is not a valid version format!`);return e=s[0].replace(/[.]/g,"-"),e in this.iddCache||await this.loadPreprocessedIDD(`${this.iddDir}/v${e}-idd${t?"":".js"}`),this.iddCache[e]}async loadPreprocessedIDD(e){try{let{iddVersion:t,iddString:s}=await import(e),i=JSON.parse(s);this.iddCache[t]=i}catch(t){throw console.error(`Failed to load '${e}'`),t}}static fromIDD(e){}};var $=class{constructor(e,t,s=!1){this.class=e,this.className=e.name,e.hasNameField?this.name=String(t.name):this.name=null,t=S(t);let[i,l]=e.getLastFieldIdxAndKeyFromFields(t,s),r=e.getFieldProps(i+1);this.fields=Object.fromEntries(Object.entries(r).filter(([n,d])=>n in t||"default"in d).map(([n,d])=>{if(n in t){let a=t[n],c=d.type;return typeof a=="string"&&(a.toLowerCase()=="autosize"||a.toLowerCase()=="autocalculate")?a=y(a):a!==null&&(a=D(c,a,this.className,n)),[n,a]}else return[n,s?null:d.default??null]}))}get(e){return this.fields[u(e)]}set(e,t){this.fields[u(e)]=t}toString(e=2,t=4,s=22){let i=" ".repeat(Math.floor(e)),l=" ".repeat(Math.floor(t)),r="",[n,d]=this.class.getLastFieldIdxAndKeyFromFields(this.fields,!0);if(n<0)return"";r+=`
${i}${this.className}
`;let a=this.class.getFieldProps(n+1);for(let[c,f]of Object.entries(a)){let h=f.name,g=String(this.fields[c]??""),p=s-String(g).length,m=" ".repeat(p>=0?p:0),F=c==d?";":",",b=f.units,I=b===null?"":` {${b}}`;r+=`${l}${g}${F}${m}  !- ${h}${I}
`}return r}},w=class{constructor(e){this.classIDD=e,this.name=e.className,this.idfObjects=[],this.fieldKeys=Object.keys(e.fields),this.hasNameField=this.fieldKeys[0]=="Name",e.extensible?(this.fieldKeys=this.fieldKeys.slice(0,e.extensible.startIdx),this.hasExtensible=!0,this.extensibleStartIdx=e.extensible.startIdx,this.extensibleSize=e.extensible.size):(this.hasExtensible=!1,this.extensibleStartIdx=-1,this.extensibleSize=0),this.fieldSize=this.fieldKeys.length}getFieldIdxByKey(e){let t=this.fieldKeys.indexOf(e);if(t>=0)return t;if(this.hasExtensible){let s=-1,i=-1;for(let l=0;l<(this.classIDD.extensible?.keyRegExps??[]).length;l++){let r=new RegExp((this.classIDD.extensible?.keyRegExps??[])[l]),n=e.match(r);if(n){s=l,i=parseInt(n[1])-1;break}}if(s<0)throw new RangeError(`'${this.name}' has no '${e}' field!`);return this.extensibleStartIdx+this.extensibleSize*i+s}else throw new RangeError(`'${this.name}' has no '${e}' field!`)}getLastFieldIdxByKeys(e){let t=-1;for(let s of e){let i=this.getFieldIdxByKey(s);i>t&&(t=i)}return t}getLastFieldIdxAndKeyFromFields(e,t=!1){let s=-1,i="";for(let[l,r]of Object.entries(e)){if(r===null)continue;let n=this.getFieldIdxByKey(l);n>s&&(s=n,i=l)}return!t&&this.classIDD.lastDefaultFieldIdx&&s<this.classIDD.lastDefaultFieldIdx&&(s=this.classIDD.lastDefaultFieldIdx,i=this.getFieldNameByIdx(s)),[s,i]}getFieldNameByIdx(e){if(e<this.fieldSize)return Object.values(this.classIDD.fields)[e].name;if(this.hasExtensible){let t=(e-this.fieldSize)%this.extensibleSize,s=Math.floor((e-this.fieldSize)/this.extensibleSize),[i,l]=this.classIDD.extensible?.fieldNames[t]??["",""];return`${i}${s+1}${l}`}else throw new RangeError(`Index ${e} is out of bound for '${this.name}'!`)}getFieldKeys(e){if(e<=this.fieldSize)return this.fieldKeys.slice(0,e);if(this.hasExtensible){let t=[...this.fieldKeys];for(let s=0;s<e-this.fieldSize;s++){let i=s%this.extensibleSize,l=Math.floor(s/this.extensibleSize),[r,n]=this.classIDD.extensible?.fieldNames[i]??["",""];t.push(u(`${r}${l+1}${n}`))}return t}else throw new RangeError(`Length ${e} is out of bound for '${this.name}'!`)}getFieldProps(e){let t=Object.values(this.classIDD.fields).length;if(e<=t)return Object.fromEntries(Object.entries(this.classIDD.fields).slice(0,e));if(this.hasExtensible){let s=Object.values(this.classIDD.fields).slice(-this.extensibleSize),i={...this.classIDD.fields};for(let l=0;l<e-t;l++){let r=l%this.extensibleSize,n=Math.floor(l/this.extensibleSize)+1,d=s[r],[a,c]=this.classIDD.extensible?.fieldNames[r]??["",""],f=`${a}${n+1}${c}`,h=u(f);i[h]={name:f,type:d.type,units:d.units}}return i}else throw new RangeError(`Length ${e} is out of bound for '${this.name}'!`)}getFieldPropByIdx(e){if(e<this.fieldSize)return Object.values(this.classIDD.fields)[e];if(this.hasExtensible){let t=(e-this.fieldSize)%this.extensibleSize,s=Math.floor((e-this.fieldSize)/this.extensibleSize),[i,l]=this.classIDD.extensible?.fieldNames[t]??["",""],r=`${i}${s+1}${l}`,n=Object.values(this.classIDD.fields)[this.extensibleStartIdx+t];return{name:r,type:n.type,units:n.units}}else throw new RangeError(`Index ${e} is out of bound for '${this.name}'!`)}getFieldNameByKey(e){}getObjectsFields(e){return this.hasNameField&&e!==void 0?this.idfObjects.filter(t=>e.test(String(t.fields.Name??""))).map(t=>t.fields):this.idfObjects.map(t=>t.fields)}},N=class o{constructor(e){this.CHECKVALID=!1;this.IDD=e,this.idfClasses={}}static async fromString(e,t="./idds",s,i=!1){if(e.length<=0)throw RangeError("Not a valid IDF string!");e=e.replace(/!.*\s*/g,""),e=e.replace(/,\s*/g,",").replace(/;\s*/g,";").trim();let l=e.match(/version,(\S+?);/i);if(l==null)throw RangeError("No version info!");let r=l[1],n;s==null?n=await new x(t).getVersion(r,i):n=await s.getVersion(r,i);let d=new o(n),a=e.split(";");for(let c=0;c<a.length;c++){let f=a[c];if(f.length<=0)continue;let h=f.split(","),g=h.shift()??"",p=d.getIDFClass(g).getFieldKeys(h.length),m=h.map((b,I)=>[p[I],b]),F=Object.fromEntries(m);d.newObject(g,F)}return d}getIDFClass(e){let t=e.toLowerCase();if(!(t in this.idfClasses)){let s=this.IDD[t];this.idfClasses[t]=new w(s)}return this.idfClasses[t]}newObject(e,t,s=!1){let i=this.getIDFClass(e);i.idfObjects.push(new $(i,t,s))}getObjects(e,t){if(!(e.toLowerCase()in this.idfClasses))throw new RangeError(`'${e}' not in this idf!`);return this.getIDFClass(e).getObjectsFields(t)}getObject(e,t){if(!this.getIDFClass(e).hasNameField)throw TypeError(`'${e}' does not have a Name field!`);let i=C(t),l=new RegExp(i),r=this.getObjects(e,l);if(r.length==0)throw RangeError(`There are no '${e}' named '${t}'!`);if(r.length>1)throw RangeError(`There are more than one '${e}' named '${t}'!`);return r[0]}toString(e=2,t=4,s=22){let i="";for(let[l,r]of Object.entries(this.idfClasses))for(let n of r.idfObjects)i+=n.toString(e,t,s);return i}};export{x as IDDManager,N as IDF};
