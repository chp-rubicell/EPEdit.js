function u(a){let e=a;return e=e.replace(/[-/*()]/g,""),e=e.replace(/ /g,"_"),e}function N(a){return Object.fromEntries(Object.entries(a).map(([e,t])=>[u(e),t]))}function y(a,e,t,s){switch(a){case"int":typeof e=="string"?e=parseInt(e):e=Math.trunc(e);break;case"float":typeof e=="string"&&(e=parseFloat(e));break;case"string":e=String(e);break;default:throw new RangeError(`Type '${a}' not supported for ${t} - ${s}`)}return e}var p=class{constructor(e="./idds"){this.iddCache={},e.endsWith("/")&&(e=e.slice(0,-1)),this.iddDir=e}async getVersion(e,t=!1){let s=e.match(/\d+[\-.]\d+/);if(s==null)throw new RangeError(`'${e}' is not a valid version format!`);return e=s[0].replace(/[.]/g,"-"),e in this.iddCache||await this.loadPreprocessedIDD(`${this.iddDir}/v${e}-idd${t?"":".js"}`),this.iddCache[e]}async loadPreprocessedIDD(e){let{iddVersion:t,iddString:s}=await import(e),i=JSON.parse(s);this.iddCache[t]=i}static fromIDD(e){}};var D=class{constructor(e,t){this.class=e,this.className=e.name,e.hasNameField?this.name=String(t.name):this.name=null,t=N(t);let[s,i]=e.getLastFieldIdxAndKeyFromFields(t),l=e.getFieldProps(s+1);this.fields=Object.fromEntries(Object.entries(l).filter(([n,r])=>n in t||"default"in r).map(([n,r])=>{if(n in t){let o=t[n],d=r.type;return typeof o=="string"&&(o.toLowerCase()=="autosize"||o.toLowerCase()=="autocalculate")?o=o.toLowerCase():o!==null&&(o=y(d,o,this.className,n)),[n,o]}else return[n,r.default??null]}))}get(e){return this.fields[u(e)]}set(e,t){this.fields[u(e)]=t}toString(e=2,t=4,s=22){let i=" ".repeat(Math.floor(e)),l=" ".repeat(Math.floor(t)),n="",[r,o]=this.class.getLastFieldIdxAndKeyFromFields(this.fields);if(r<0)return"";n+=`
${i}${this.className}
`;let d=this.class.getFieldProps(r+1);for(let[c,f]of Object.entries(d)){let h=f.name,g=String(this.fields[c]??""),x=s-String(g).length,b=" ".repeat(x>=0?x:0),I=c==o?";":",",m=f.units,F=m===null?"":` {${m}}`;n+=`${l}${g}${I}${b}  !- ${h}${F}
`}return n}},w=class{constructor(e){this.classIDD=e,this.name=e.className,this.idfObjects=[],this.fieldKeys=Object.keys(e.fields),this.hasNameField=Object.keys(this.fieldKeys)[0]=="Name",e.extensible?(this.fieldKeys=this.fieldKeys.slice(0,e.extensible.startIdx),this.hasExtensible=!0,this.extensibleStartIdx=e.extensible.startIdx,this.extensibleSize=e.extensible.size):(this.hasExtensible=!1,this.extensibleStartIdx=-1,this.extensibleSize=0),this.fieldSize=this.fieldKeys.length}getFieldIdxByKey(e){let t=this.fieldKeys.indexOf(e);if(t>=0)return t;if(this.hasExtensible){let s=-1,i=-1;for(let l=0;l<(this.classIDD.extensible?.keyRegExps??[]).length;l++){let n=new RegExp((this.classIDD.extensible?.keyRegExps??[])[l]),r=e.match(n);if(r){s=l,i=parseInt(r[1])-1;break}}if(s<0)throw new RangeError(`'${this.name}' has no '${e}' field!`);return this.extensibleStartIdx+this.extensibleSize*i+s}else throw new RangeError(`'${this.name}' has no '${e}' field!`)}getLastFieldIdxByKeys(e){let t=-1;for(let s of e){let i=this.getFieldIdxByKey(s);i>t&&(t=i)}return t}getLastFieldIdxAndKeyFromFields(e){let t=-1,s="";for(let[i,l]of Object.entries(e)){if(l===null)continue;let n=this.getFieldIdxByKey(i);n>t&&(t=n,s=i)}return[t,s]}getFieldNameByIdx(e){if(e<this.fieldSize)return Object.values(this.classIDD.fields)[e].name;if(this.hasExtensible){let t=(e-this.fieldSize)%this.extensibleSize,s=Math.floor((e-this.fieldSize)/this.extensibleSize),[i,l]=this.classIDD.extensible?.fieldNames[t]??["",""];return`${i}${s+1}${l}`}else throw new RangeError(`Index ${e} is out of bound for '${this.name}'!`)}getFieldKeys(e){if(e<=this.fieldSize)return this.fieldKeys.slice(0,e);if(this.hasExtensible){let t=[...this.fieldKeys];for(let s=0;s<e-this.fieldSize;s++){let i=s%this.extensibleSize,l=Math.floor(s/this.extensibleSize),[n,r]=this.classIDD.extensible?.fieldNames[i]??["",""];t.push(u(`${n}${l+1}${r}`))}return t}else throw new RangeError(`Length ${e} is out of bound for '${this.name}'!`)}getFieldProps(e){let t=Object.values(this.classIDD.fields).length;if(e<=t)return Object.fromEntries(Object.entries(this.classIDD.fields).slice(0,e));if(this.hasExtensible){let s=Object.values(this.classIDD.fields).slice(-this.extensibleSize),i={...this.classIDD.fields};for(let l=0;l<e-t;l++){let n=l%this.extensibleSize,r=Math.floor(l/this.extensibleSize)+1,o=s[n],[d,c]=this.classIDD.extensible?.fieldNames[n]??["",""],f=`${d}${r+1}${c}`,h=u(f);i[h]={name:f,type:o.type,units:o.units}}return i}else throw new RangeError(`Length ${e} is out of bound for '${this.name}'!`)}getFieldPropByIdx(e){if(e<this.fieldSize)return Object.values(this.classIDD.fields)[e];if(this.hasExtensible){let t=(e-this.fieldSize)%this.extensibleSize,s=Math.floor((e-this.fieldSize)/this.extensibleSize),[i,l]=this.classIDD.extensible?.fieldNames[t]??["",""],n=`${i}${s+1}${l}`,r=Object.values(this.classIDD.fields)[this.extensibleStartIdx+t];return{name:n,type:r.type,units:r.units}}else throw new RangeError(`Index ${e} is out of bound for '${this.name}'!`)}getFieldNameByKey(e){}getObjectsFields(e){return this.hasNameField&&e!==void 0?this.idfObjects.filter(t=>e.test(String(t.fields.Name??""))).map(t=>t.fields):this.idfObjects.map(t=>t.fields)}},$=class a{constructor(e){this.CHECKVALID=!1;this.IDD=e,this.idfClasses={}}static async fromString(e,t="./idds",s,i=!1){if(e.length<=0)throw RangeError("Not a valid IDF string!");e=e.replace(/!.*\s*/g,""),e=e.replace(/,\s*/g,",").replace(/;\s*/g,";").trim();let l=e.match(/version,(\S+?);/i);if(l==null)throw RangeError("No version info!");let n=l[1],r;s==null?r=await new p(t).getVersion(n,i):r=await s.getVersion(n,i);let o=new a(r),d=e.split(";");for(let c=0;c<d.length;c++){let f=d[c];if(f.length<=0)continue;let h=f.split(","),g=h.shift()??"",x=o.getIDFClass(g).getFieldKeys(h.length),b=h.map((m,F)=>[x[F],m]),I=Object.fromEntries(b);o.newObject(g,I)}return o}getIDFClass(e){let t=e.toLowerCase();if(!(t in this.idfClasses)){let s=this.IDD[t];this.idfClasses[t]=new w(s)}return this.idfClasses[t]}newObject(e,t){let s=this.getIDFClass(e);s.idfObjects.push(new D(s,t))}getObjects(e,t){if(!(e.toLowerCase()in this.idfClasses))throw new RangeError(`'${e}' not in this idf!`);return this.getIDFClass(e).getObjectsFields(t)}toString(e=2,t=4,s=22){let i="";for(let[l,n]of Object.entries(this.idfClasses))for(let r of n.idfObjects)i+=r.toString(e,t,s);return i}};export{p as IDDManager,$ as IDF};
