function w(a){return Object.fromEntries(Object.entries(a).map(([e,s])=>[h(e),s]))}function h(a){let e=a;return e=e.replace(/[-/*()]/g,""),e=e.replace(/ /g,"_"),e}var u=class{constructor(e="./idds"){this.iddCache={},e.endsWith("/")&&(e=e.slice(0,-1)),this.iddDir=e}async getVersion(e,s=!1){let t=e.match(/\d+[\-.]\d+/);if(t==null)throw new RangeError(`'${e}' is not a valid version format!`);return e=t[0].replace(/[.]/g,"-"),e in this.iddCache||await this.loadPreprocessedIDD(`${this.iddDir}/v${e}-idd${s?"":".js"}`),this.iddCache[e]}async loadPreprocessedIDD(e){let{iddVersion:s,iddString:t}=await import(e),n=JSON.parse(t);this.iddCache[s]=n}static fromIDD(e){}};var D=class{constructor(e,s){this.class=e,this.className=e.name,e.hasNameField?this.name=String(s.name):this.name=null,s=w(s);let[t,n]=e.getLastFieldIdxAndKeyFromFields(s),r=e.getFieldProps(t+1);this.fields=Object.fromEntries(Object.entries(s).map(([l,i])=>{let o=r[l].type;if(typeof i=="string"&&(i.toLowerCase()=="autosize"||i.toLowerCase()=="autocalculate"))i=i.toLowerCase();else if(i!==null)switch(o){case"int":typeof i=="string"?i=parseInt(i):i=Math.trunc(i);break;case"float":typeof i=="string"&&(i=parseFloat(i));break;case"string":i=String(i);break;default:throw new RangeError(`Type '${o}' not supported for ${this.className} - ${this.name}`)}return[l,i]}))}get(e){return this.fields[h(e)]}set(e,s){this.fields[h(e)]=s}toString(e=2,s=4,t=22){let n=" ".repeat(Math.floor(e)),r=" ".repeat(Math.floor(s)),l="",[i,o]=this.class.getLastFieldIdxAndKeyFromFields(this.fields);if(i<0)return"";l+=`
${n}${this.className}
`;let g=this.class.getFieldProps(i+1);for(let[d,c]of Object.entries(g)){let f=c.name,x=String(this.fields[d]??""),b=t-String(x).length,p=" ".repeat(b>=0?b:0),I=d==o?";":",",m=c.units,y=m===null?"":` {${m}}`;l+=`${r}${x}${I}${p}  !- ${f}${y}
`}return l}},F=class{constructor(e){this.classIDD=e,this.name=e.className,this.idfObjects=[],this.fieldKeys=Object.keys(e.fields),this.hasNameField=Object.keys(this.fieldKeys)[0]=="Name",e.extensible?(this.fieldKeys=this.fieldKeys.slice(0,e.extensible.startIdx),this.hasExtensible=!0,this.extensibleStartIdx=e.extensible.startIdx,this.extensibleSize=e.extensible.size):(this.hasExtensible=!1,this.extensibleStartIdx=-1,this.extensibleSize=0),this.fieldSize=this.fieldKeys.length}getFieldIdxByKey(e){let s=this.fieldKeys.indexOf(e);if(s>=0)return s;if(this.hasExtensible){let t=-1,n=-1;for(let r=0;r<(this.classIDD.extensible?.keyRegExps??[]).length;r++){let l=new RegExp((this.classIDD.extensible?.keyRegExps??[])[r]),i=e.match(l);if(i){t=r,n=parseInt(i[1])-1;break}}if(t<0)throw new RangeError(`'${this.name}' has no '${e}' field!`);return this.extensibleStartIdx+this.extensibleSize*n+t}else throw new RangeError(`'${this.name}' has no '${e}' field!`)}getLastFieldIdxByKeys(e){let s=-1;for(let t of e){let n=this.getFieldIdxByKey(t);n>s&&(s=n)}return s}getLastFieldIdxAndKeyFromFields(e){let s=-1,t="";for(let[n,r]of Object.entries(e)){if(r===null)continue;let l=this.getFieldIdxByKey(n);l>s&&(s=l,t=n)}return[s,t]}getFieldNameByIdx(e){if(e<this.fieldSize)return Object.values(this.classIDD.fields)[e].name;if(this.hasExtensible){let s=(e-this.fieldSize)%this.extensibleSize,t=Math.floor((e-this.fieldSize)/this.extensibleSize),[n,r]=this.classIDD.extensible?.fieldNames[s]??["",""];return`${n}${t+1}${r}`}else throw new RangeError(`Index ${e} is out of bound for '${this.name}'!`)}getFieldKeys(e){if(e<=this.fieldSize)return this.fieldKeys.slice(0,e);if(this.hasExtensible){let s=[...this.fieldKeys];for(let t=0;t<e-this.fieldSize;t++){let n=t%this.extensibleSize,r=Math.floor(t/this.extensibleSize),[l,i]=this.classIDD.extensible?.fieldNames[n]??["",""];s.push(h(`${l}${r+1}${i}`))}return s}else throw new RangeError(`Length ${e} is out of bound for '${this.name}'!`)}getFieldProps(e){let s=Object.values(this.classIDD.fields).length;if(e<=s)return Object.fromEntries(Object.entries(this.classIDD.fields).slice(0,e));if(this.hasExtensible){let t=Object.values(this.classIDD.fields).slice(-this.extensibleSize),n={...this.classIDD.fields};for(let r=0;r<e-s;r++){let l=r%this.extensibleSize,i=Math.floor(r/this.extensibleSize)+1,o=t[l],[g,d]=this.classIDD.extensible?.fieldNames[l]??["",""],c=`${g}${i+1}${d}`,f=h(c);n[f]={name:c,type:o.type,units:o.units}}return n}else throw new RangeError(`Length ${e} is out of bound for '${this.name}'!`)}getFieldPropByIdx(e){if(e<this.fieldSize)return Object.values(this.classIDD.fields)[e];if(this.hasExtensible){let s=(e-this.fieldSize)%this.extensibleSize,t=Math.floor((e-this.fieldSize)/this.extensibleSize),[n,r]=this.classIDD.extensible?.fieldNames[s]??["",""],l=`${n}${t+1}${r}`,i=Object.values(this.classIDD.fields)[this.extensibleStartIdx+s];return{name:l,type:i.type,units:i.units}}else throw new RangeError(`Index ${e} is out of bound for '${this.name}'!`)}getFieldNameByKey(e){}getObjectsFields(e){return this.hasNameField&&e!==void 0?this.idfObjects.filter(s=>e.test(String(s.fields.Name??""))).map(s=>s.fields):this.idfObjects.map(s=>s.fields)}},$=class a{constructor(e){this.CHECKVALID=!1;this.IDD=e,this.idfClasses={}}static async fromString(e,s="./idds",t,n=!1){if(e.length<=0)throw RangeError("Not a valid IDF string!");e=e.replace(/!.*\s*/g,""),e=e.replace(/,\s*/g,",").replace(/;\s*/g,";").trim();let r=e.match(/version,(\S+?);/i);if(r==null)throw RangeError("No version info!");let l=r[1],i;t==null?i=await new u(s).getVersion(l,n):i=await t.getVersion(l,n);let o=new a(i),g=e.split(";");for(let d=0;d<g.length;d++){let c=g[d];if(c.length<=0)continue;let f=c.split(","),x=f.shift()??"",b=o.getIDFClass(x).getFieldKeys(f.length),p=f.map((m,y)=>[b[y],m]),I=Object.fromEntries(p);o.newObject(x,I)}return o}getIDFClass(e){let s=e.toLowerCase();if(!(s in this.idfClasses)){let t=this.IDD[s];this.idfClasses[s]=new F(t)}return this.idfClasses[s]}newObject(e,s){let t=this.getIDFClass(e);t.idfObjects.push(new D(t,s))}getObjects(e,s){if(!(e.toLowerCase()in this.idfClasses))throw new RangeError(`'${e}' not in this idf!`);return this.getIDFClass(e).getObjectsFields(s)}toString(e=2,s=4,t=22){let n="";for(let[r,l]of Object.entries(this.idfClasses))for(let i of l.idfObjects)n+=i.toString(e,s,t);return n}};export{u as IDDManager,$ as IDF};
