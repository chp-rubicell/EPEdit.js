function u(r){let e=r;return e=e.replace(/[-/*()]/g,""),e=e.replace(/ /g,"_"),e}function $(r){return Object.fromEntries(Object.entries(r).map(([e,t])=>[u(e),t]))}function y(r,e,t,s){switch(r){case"int":typeof e=="string"?e=parseInt(e):e=Math.trunc(e);break;case"float":typeof e=="string"&&(e=parseFloat(e));break;case"string":e=String(e);break;default:throw new RangeError(`Type '${r}' not supported for ${t} - ${s}`)}return e}function C(r,e){let t=[],s=Math.max(r.length,e.length);for(let i=0;i<s;i++)i<r.length&&t.push(r[i]),i<e.length&&t.push(e[i]);return t}function w(r,e=/[ ]/){if(!r)return"";e=new RegExp(e.source,"g");let t=r.match(e)??[],s=r.toLowerCase().split(e).map(i=>i.charAt(0).toUpperCase()+i.slice(1));return C(s,t).join("")}var g=class{constructor(e="./idds"){this.iddCache={},e.endsWith("/")&&(e=e.slice(0,-1)),this.iddDir=e}async getVersion(e,t=!1){let s=e.match(/\d+[\-.]\d+/);if(s==null)throw new RangeError(`'${e}' is not a valid version format!`);return e=s[0].replace(/[.]/g,"-"),e in this.iddCache||await this.loadPreprocessedIDD(`${this.iddDir}/v${e}-idd${t?"":".js"}`),this.iddCache[e]}async loadPreprocessedIDD(e){let{iddVersion:t,iddString:s}=await import(e),i=JSON.parse(s);this.iddCache[t]=i}static fromIDD(e){}};var N=class{constructor(e,t,s=!1){this.class=e,this.className=e.name,e.hasNameField?this.name=String(t.name):this.name=null,t=$(t);let[i,l]=e.getLastFieldIdxAndKeyFromFields(t,s),a=e.getFieldProps(i+1);this.fields=Object.fromEntries(Object.entries(a).filter(([n,d])=>n in t||"default"in d).map(([n,d])=>{if(n in t){let o=t[n],c=d.type;return typeof o=="string"&&(o.toLowerCase()=="autosize"||o.toLowerCase()=="autocalculate")?o=w(o):o!==null&&(o=y(c,o,this.className,n)),[n,o]}else return[n,s?null:d.default??null]}))}get(e){return this.fields[u(e)]}set(e,t){this.fields[u(e)]=t}toString(e=2,t=4,s=22){let i=" ".repeat(Math.floor(e)),l=" ".repeat(Math.floor(t)),a="",[n,d]=this.class.getLastFieldIdxAndKeyFromFields(this.fields,!0);if(n<0)return"";a+=`
${i}${this.className}
`;let o=this.class.getFieldProps(n+1);for(let[c,f]of Object.entries(o)){let h=f.name,x=String(this.fields[c]??""),p=s-String(x).length,I=" ".repeat(p>=0?p:0),F=c==d?";":",",m=f.units,D=m===null?"":` {${m}}`;a+=`${l}${x}${F}${I}  !- ${h}${D}
`}return a}},S=class{constructor(e){this.classIDD=e,this.name=e.className,this.idfObjects=[],this.fieldKeys=Object.keys(e.fields),this.hasNameField=Object.keys(this.fieldKeys)[0]=="Name",e.extensible?(this.fieldKeys=this.fieldKeys.slice(0,e.extensible.startIdx),this.hasExtensible=!0,this.extensibleStartIdx=e.extensible.startIdx,this.extensibleSize=e.extensible.size):(this.hasExtensible=!1,this.extensibleStartIdx=-1,this.extensibleSize=0),this.fieldSize=this.fieldKeys.length}getFieldIdxByKey(e){let t=this.fieldKeys.indexOf(e);if(t>=0)return t;if(this.hasExtensible){let s=-1,i=-1;for(let l=0;l<(this.classIDD.extensible?.keyRegExps??[]).length;l++){let a=new RegExp((this.classIDD.extensible?.keyRegExps??[])[l]),n=e.match(a);if(n){s=l,i=parseInt(n[1])-1;break}}if(s<0)throw new RangeError(`'${this.name}' has no '${e}' field!`);return this.extensibleStartIdx+this.extensibleSize*i+s}else throw new RangeError(`'${this.name}' has no '${e}' field!`)}getLastFieldIdxByKeys(e){let t=-1;for(let s of e){let i=this.getFieldIdxByKey(s);i>t&&(t=i)}return t}getLastFieldIdxAndKeyFromFields(e,t=!1){let s=-1,i="";for(let[l,a]of Object.entries(e)){if(a===null)continue;let n=this.getFieldIdxByKey(l);n>s&&(s=n,i=l)}return!t&&this.classIDD.lastDefaultFieldIdx&&s<this.classIDD.lastDefaultFieldIdx&&(s=this.classIDD.lastDefaultFieldIdx,i=this.getFieldNameByIdx(s)),[s,i]}getFieldNameByIdx(e){if(e<this.fieldSize)return Object.values(this.classIDD.fields)[e].name;if(this.hasExtensible){let t=(e-this.fieldSize)%this.extensibleSize,s=Math.floor((e-this.fieldSize)/this.extensibleSize),[i,l]=this.classIDD.extensible?.fieldNames[t]??["",""];return`${i}${s+1}${l}`}else throw new RangeError(`Index ${e} is out of bound for '${this.name}'!`)}getFieldKeys(e){if(e<=this.fieldSize)return this.fieldKeys.slice(0,e);if(this.hasExtensible){let t=[...this.fieldKeys];for(let s=0;s<e-this.fieldSize;s++){let i=s%this.extensibleSize,l=Math.floor(s/this.extensibleSize),[a,n]=this.classIDD.extensible?.fieldNames[i]??["",""];t.push(u(`${a}${l+1}${n}`))}return t}else throw new RangeError(`Length ${e} is out of bound for '${this.name}'!`)}getFieldProps(e){let t=Object.values(this.classIDD.fields).length;if(e<=t)return Object.fromEntries(Object.entries(this.classIDD.fields).slice(0,e));if(this.hasExtensible){let s=Object.values(this.classIDD.fields).slice(-this.extensibleSize),i={...this.classIDD.fields};for(let l=0;l<e-t;l++){let a=l%this.extensibleSize,n=Math.floor(l/this.extensibleSize)+1,d=s[a],[o,c]=this.classIDD.extensible?.fieldNames[a]??["",""],f=`${o}${n+1}${c}`,h=u(f);i[h]={name:f,type:d.type,units:d.units}}return i}else throw new RangeError(`Length ${e} is out of bound for '${this.name}'!`)}getFieldPropByIdx(e){if(e<this.fieldSize)return Object.values(this.classIDD.fields)[e];if(this.hasExtensible){let t=(e-this.fieldSize)%this.extensibleSize,s=Math.floor((e-this.fieldSize)/this.extensibleSize),[i,l]=this.classIDD.extensible?.fieldNames[t]??["",""],a=`${i}${s+1}${l}`,n=Object.values(this.classIDD.fields)[this.extensibleStartIdx+t];return{name:a,type:n.type,units:n.units}}else throw new RangeError(`Index ${e} is out of bound for '${this.name}'!`)}getFieldNameByKey(e){}getObjectsFields(e){return this.hasNameField&&e!==void 0?this.idfObjects.filter(t=>e.test(String(t.fields.Name??""))).map(t=>t.fields):this.idfObjects.map(t=>t.fields)}},b=class r{constructor(e){this.CHECKVALID=!1;this.IDD=e,this.idfClasses={}}static async fromString(e,t="./idds",s,i=!1){if(e.length<=0)throw RangeError("Not a valid IDF string!");e=e.replace(/!.*\s*/g,""),e=e.replace(/,\s*/g,",").replace(/;\s*/g,";").trim();let l=e.match(/version,(\S+?);/i);if(l==null)throw RangeError("No version info!");let a=l[1],n;s==null?n=await new g(t).getVersion(a,i):n=await s.getVersion(a,i);let d=new r(n),o=e.split(";");for(let c=0;c<o.length;c++){let f=o[c];if(f.length<=0)continue;let h=f.split(","),x=h.shift()??"",p=d.getIDFClass(x).getFieldKeys(h.length),I=h.map((m,D)=>[p[D],m]),F=Object.fromEntries(I);d.newObject(x,F)}return d}getIDFClass(e){let t=e.toLowerCase();if(!(t in this.idfClasses)){let s=this.IDD[t];this.idfClasses[t]=new S(s)}return this.idfClasses[t]}newObject(e,t,s=!1){let i=this.getIDFClass(e);i.idfObjects.push(new N(i,t,s))}getObjects(e,t){if(!(e.toLowerCase()in this.idfClasses))throw new RangeError(`'${e}' not in this idf!`);return this.getIDFClass(e).getObjectsFields(t)}toString(e=2,t=4,s=22){let i="";for(let[l,a]of Object.entries(this.idfClasses))for(let n of a.idfObjects)i+=n.toString(e,t,s);return i}};async function j(){let r=await new g().getVersion("23.2",!0),e=new b(r);e.newObject("buildingsurface:detailed",{Wind_Exposure:"NoWind"}),console.log(e.toString()),e=new b(r),e.newObject("buildingsurface:detailed",{Wind_Exposure:"NoWind"},!0),console.log(e.toString())}j();export{g as IDDManager,b as IDF};
