function $(c){return Object.fromEntries(Object.entries(c).map(([e,s])=>[h(e),s]))}function h(c){let e=c;return e=e.replace(/[-/*()]/g,""),e=e.replace(/ /g,"_"),e}var x=class{constructor(e="./idds"){this.iddCache={},e.endsWith("/")&&(e=e.slice(0,-1)),this.iddDir=e}async getVersion(e,s=!1){let t=e.match(/\d+[\-.]\d+/);if(t==null)throw new RangeError(`'${e}' is not a valid version format!`);return e=t[0].replace(/[.]/g,"-"),e in this.iddCache||await this.loadPreprocessedIDD(`${this.iddDir}/v${e}-idd${s?"":".js"}`),this.iddCache[e]}async loadPreprocessedIDD(e){let{iddVersion:s,iddString:t}=await import(e),n=JSON.parse(t);this.iddCache[s]=n}static fromIDD(e){}};var y=class{constructor(e,s){this.class=e,this.className=e.name,e.hasNameField?this.name=String(s.name):this.name=null,s=$(s);let[t,n]=e.getLastFieldIdxAndKeyFromFields(s),r=e.getFieldProps(t+1);this.fields=Object.fromEntries(Object.entries(s).map(([l,i])=>{let o=r[l].type;if(typeof i=="string"&&(i.toLowerCase()=="autosize"||i.toLowerCase()=="autocalculate"))i=i.toLowerCase();else if(i!==null)switch(o){case"int":typeof i=="string"?i=parseInt(i):i=Math.trunc(i);break;case"float":typeof i=="string"&&(i=parseFloat(i));break;case"string":i=String(i);break;default:throw new RangeError(`Type '${o}' not supported for ${this.className} - ${this.name}`)}return[l,i]}))}get(e){return this.fields[h(e)]}set(e,s){this.fields[h(e)]=s}toString(e=2,s=4,t=22){let n=" ".repeat(Math.floor(e)),r=" ".repeat(Math.floor(s)),l="",[i,o]=this.class.getLastFieldIdxAndKeyFromFields(this.fields);if(i<0)return"";l+=`
${n}${this.className}
`;let a=this.class.getFieldProps(i+1);for(let[f,d]of Object.entries(a)){let g=d.name,u=String(this.fields[f]??""),b=t-String(u).length,p=" ".repeat(b>=0?b:0),I=f==o?";":",",m=d.units,w=m===null?"":` {${m}}`;l+=`${r}${u}${I}${p}  !- ${g}${w}
`}return l}},D=class{constructor(e){this.classIDD=e,this.name=e.className,this.idfObjects=[],this.fieldKeys=Object.keys(e.fields),this.hasNameField=Object.keys(this.fieldKeys)[0]=="Name",e.extensible?(this.fieldKeys=this.fieldKeys.slice(0,e.extensible.startIdx),this.hasExtensible=!0,this.extensibleStartIdx=e.extensible.startIdx,this.extensibleSize=e.extensible.size):(this.hasExtensible=!1,this.extensibleStartIdx=-1,this.extensibleSize=0),this.fieldSize=this.fieldKeys.length}getFieldIdxByKey(e){let s=this.fieldKeys.indexOf(e);if(s>=0)return s;if(this.hasExtensible){let t=-1,n=-1;for(let r=0;r<(this.classIDD.extensible?.keyRegExps??[]).length;r++){let l=new RegExp((this.classIDD.extensible?.keyRegExps??[])[r]),i=e.match(l);if(i){t=r,n=parseInt(i[1])-1;break}}if(t<0)throw new RangeError(`'${this.name}' has no '${e}' field!`);return this.extensibleStartIdx+this.extensibleSize*n+t}else throw new RangeError(`'${this.name}' has no '${e}' field!`)}getLastFieldIdxByKeys(e){let s=-1;for(let t of e){let n=this.getFieldIdxByKey(t);n>s&&(s=n)}return s}getLastFieldIdxAndKeyFromFields(e){let s=-1,t="";for(let[n,r]of Object.entries(e)){if(r===null)continue;let l=this.getFieldIdxByKey(n);l>s&&(s=l,t=n)}return[s,t]}getFieldNameByIdx(e){if(e<this.fieldSize)return Object.values(this.classIDD.fields)[e].name;if(this.hasExtensible){let s=(e-this.fieldSize)%this.extensibleSize,t=Math.floor((e-this.fieldSize)/this.extensibleSize),[n,r]=this.classIDD.extensible?.fieldNames[s]??["",""];return`${n}${t+1}${r}`}else throw new RangeError(`Index ${e} is out of bound for '${this.name}'!`)}getFieldKeys(e){if(e<=this.fieldSize)return this.fieldKeys.slice(0,e);if(this.hasExtensible){let s=[...this.fieldKeys];for(let t=0;t<e-this.fieldSize;t++){let n=t%this.extensibleSize,r=Math.floor(t/this.extensibleSize),[l,i]=this.classIDD.extensible?.fieldNames[n]??["",""];s.push(h(`${l}${r+1}${i}`))}return s}else throw new RangeError(`Length ${e} is out of bound for '${this.name}'!`)}getFieldProps(e){let s=Object.values(this.classIDD.fields).length;if(e<=s)return Object.fromEntries(Object.entries(this.classIDD.fields).slice(0,e));if(this.hasExtensible){let t=Object.values(this.classIDD.fields).slice(-this.extensibleSize),n={...this.classIDD.fields};for(let r=0;r<e-s;r++){let l=r%this.extensibleSize,i=Math.floor(r/this.extensibleSize)+1,o=t[l],[a,f]=this.classIDD.extensible?.fieldNames[l]??["",""],d=`${a}${i+1}${f}`,g=h(d);n[g]={name:d,type:o.type,units:o.units}}return n}else throw new RangeError(`Length ${e} is out of bound for '${this.name}'!`)}getFieldPropByIdx(e){if(e<this.fieldSize)return Object.values(this.classIDD.fields)[e];if(this.hasExtensible){let s=(e-this.fieldSize)%this.extensibleSize,t=Math.floor((e-this.fieldSize)/this.extensibleSize),[n,r]=this.classIDD.extensible?.fieldNames[s]??["",""],l=`${n}${t+1}${r}`,i=Object.values(this.classIDD.fields)[this.extensibleStartIdx+s];return{name:l,type:i.type,units:i.units}}else throw new RangeError(`Index ${e} is out of bound for '${this.name}'!`)}getFieldNameByKey(e){}getObjectsFields(e){return this.hasNameField&&e!==void 0?this.idfObjects.filter(s=>e.test(String(s.fields.Name??""))).map(s=>s.fields):this.idfObjects.map(s=>s.fields)}},F=class c{constructor(e){this.CHECKVALID=!1;this.IDD=e,this.idfClasses={}}static async fromString(e,s,t=!1){if(e.length<=0)throw RangeError("Not a valid IDF string!");e=e.replace(/!.*\s*/g,""),e=e.replace(/,\s*/g,",").replace(/;\s*/g,";").trim();let n=e.match(/version,(\S+?);/i);if(n==null)throw RangeError("No version info!");let r=n[1],l;s==null?l=await new x().getVersion(r,t):l=await s.getVersion(r,t);let i=new c(l),o=e.split(";");for(let a=0;a<o.length;a++){let f=o[a];if(f.length<=0)continue;let d=f.split(","),g=d.shift()??"",u=i.getIDFClass(g).getFieldKeys(d.length),b=d.map((I,m)=>[u[m],I]),p=Object.fromEntries(b);i.addObject(g,p)}return i}getIDFClass(e){let s=e.toLowerCase();if(!(s in this.idfClasses)){let t=this.IDD[s];this.idfClasses[s]=new D(t)}return this.idfClasses[s]}addObject(e,s){let t=this.getIDFClass(e);t.idfObjects.push(new y(t,s))}getObjects(e,s){if(!(e.toLowerCase()in this.idfClasses))throw new RangeError(`'${e}' not in this idf!`);return this.getIDFClass(e).getObjectsFields(s)}toString(e=2,s=4,t=22){let n=" ".repeat(Math.floor(e)),r=" ".repeat(Math.floor(s)),l="";for(let[i,o]of Object.entries(this.idfClasses))for(let a of o.idfObjects)l+=a.toString();return l}};export{x as IDDManager,F as IDF};
