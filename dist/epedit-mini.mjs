var $=a=>e=>{var t=a[e];if(t)return t();throw new Error("Module not found in bundle: "+e)};function w(a){return Object.fromEntries(Object.entries(a).map(([e,t])=>[h(e),t]))}function h(a){let e=a;return e=e.replace(/[-/*()]/g,""),e=e.replace(/ /g,"_"),e}var E=$({});async function R(a){let{iddString:e}=await E(`./idds/v${a}-idd`);return e}var x=class{constructor(){this.iddCache={}}async getVersion(e){let t=e.match(/\d+[\-.]\d+/);if(t==null)throw new RangeError(`'${e}' is not a valid version format!`);if(e=t[0].replace(/[.]/g,"-"),!(e in this.iddCache)){let s=await R(e),n=JSON.parse(s);this.iddCache[e]=n}return this.iddCache[e]}static fromIDD(e){}};var I=class{constructor(e,t){this.class=e,this.className=e.name,e.hasNameField?this.name=String(t.name):this.name=null,t=w(t);let[s,n]=e.getLastFieldIdxAndKeyFromFields(t),r=e.getFieldProps(s+1);this.fields=Object.fromEntries(Object.entries(t).map(([l,i])=>{let o=r[l].type;if(typeof i=="string"&&(i.toLowerCase()=="autosize"||i.toLowerCase()=="autocalculate"))i=i.toLowerCase();else if(i!==null)switch(o){case"int":typeof i=="string"?i=parseInt(i):i=Math.trunc(i);break;case"float":typeof i=="string"&&(i=parseFloat(i));break;case"string":i=String(i);break;default:throw new RangeError(`Type '${o}' not supported for ${this.className} - ${this.name}`)}return[l,i]}))}get(e){return this.fields[h(e)]}set(e,t){this.fields[h(e)]=t}toString(e=2,t=4,s=22){let n=" ".repeat(Math.floor(e)),r=" ".repeat(Math.floor(t)),l="",[i,o]=this.class.getLastFieldIdxAndKeyFromFields(this.fields);if(i<0)return"";l+=`
${n}${this.className}
`;let d=this.class.getFieldProps(i+1);for(let[c,f]of Object.entries(d)){let g=f.name,u=String(this.fields[c]??""),m=s-String(u).length,b=" ".repeat(m>=0?m:0),p=c==o?";":",",D=f.units,N=D===null?"":` {${D}}`;l+=`${r}${u}${p}${b}  !- ${g}${N}
`}return l}},y=class{constructor(e){this.classIDD=e,this.name=e.className,this.idfObjects=[],this.fieldKeys=Object.keys(e.fields),this.hasNameField=Object.keys(this.fieldKeys)[0]=="Name",e.extensible?(this.fieldKeys=this.fieldKeys.slice(0,e.extensible.startIdx),this.hasExtensible=!0,this.extensibleStartIdx=e.extensible.startIdx,this.extensibleSize=e.extensible.size):(this.hasExtensible=!1,this.extensibleStartIdx=-1,this.extensibleSize=0),this.fieldSize=this.fieldKeys.length}getFieldIdxByKey(e){let t=this.fieldKeys.indexOf(e);if(t>=0)return t;if(this.hasExtensible){let s=-1,n=-1;for(let r=0;r<(this.classIDD.extensible?.keyRegExps??[]).length;r++){let l=new RegExp((this.classIDD.extensible?.keyRegExps??[])[r]),i=e.match(l);if(i){s=r,n=parseInt(i[1])-1;break}}if(s<0)throw new RangeError(`'${this.name}' has no '${e}' field!`);return this.extensibleStartIdx+this.extensibleSize*n+s}else throw new RangeError(`'${this.name}' has no '${e}' field!`)}getLastFieldIdxByKeys(e){let t=-1;for(let s of e){let n=this.getFieldIdxByKey(s);n>t&&(t=n)}return t}getLastFieldIdxAndKeyFromFields(e){let t=-1,s="";for(let[n,r]of Object.entries(e)){if(r===null)continue;let l=this.getFieldIdxByKey(n);l>t&&(t=l,s=n)}return[t,s]}getFieldNameByIdx(e){if(e<this.fieldSize)return Object.values(this.classIDD.fields)[e].name;if(this.hasExtensible){let t=(e-this.fieldSize)%this.extensibleSize,s=Math.floor((e-this.fieldSize)/this.extensibleSize),[n,r]=this.classIDD.extensible?.fieldNames[t]??["",""];return`${n}${s+1}${r}`}else throw new RangeError(`Index ${e} is out of bound for '${this.name}'!`)}getFieldKeys(e){if(e<=this.fieldSize)return this.fieldKeys.slice(0,e);if(this.hasExtensible){let t=[...this.fieldKeys];for(let s=0;s<e-this.fieldSize;s++){let n=s%this.extensibleSize,r=Math.floor(s/this.extensibleSize),[l,i]=this.classIDD.extensible?.fieldNames[n]??["",""];t.push(h(`${l}${r+1}${i}`))}return t}else throw new RangeError(`Length ${e} is out of bound for '${this.name}'!`)}getFieldProps(e){let t=Object.values(this.classIDD.fields).length;if(e<=t)return Object.fromEntries(Object.entries(this.classIDD.fields).slice(0,e));if(this.hasExtensible){let s=Object.values(this.classIDD.fields).slice(-this.extensibleSize),n={...this.classIDD.fields};for(let r=0;r<e-t;r++){let l=r%this.extensibleSize,i=Math.floor(r/this.extensibleSize)+1,o=s[l],[d,c]=this.classIDD.extensible?.fieldNames[l]??["",""],f=`${d}${i+1}${c}`,g=h(f);n[g]={name:f,type:o.type,units:o.units}}return n}else throw new RangeError(`Length ${e} is out of bound for '${this.name}'!`)}getFieldPropByIdx(e){if(e<this.fieldSize)return Object.values(this.classIDD.fields)[e];if(this.hasExtensible){let t=(e-this.fieldSize)%this.extensibleSize,s=Math.floor((e-this.fieldSize)/this.extensibleSize),[n,r]=this.classIDD.extensible?.fieldNames[t]??["",""],l=`${n}${s+1}${r}`,i=Object.values(this.classIDD.fields)[this.extensibleStartIdx+t];return{name:l,type:i.type,units:i.units}}else throw new RangeError(`Index ${e} is out of bound for '${this.name}'!`)}getFieldNameByKey(e){}getObjectsFields(e){return this.hasNameField&&e!==void 0?this.idfObjects.filter(t=>e.test(String(t.fields.Name??""))).map(t=>t.fields):this.idfObjects.map(t=>t.fields)}},F=class a{constructor(e){this.CHECKVALID=!1;this.IDD=e,this.idfClasses={}}static async fromString(e,t){if(e.length<=0)throw RangeError("Not a valid IDF string!");e=e.replace(/!.*\s*/g,""),e=e.replace(/,\s*/g,",").replace(/;\s*/g,";").trim();let s=e.match(/version,(\S+?);/i);if(s==null)throw RangeError("No version info!");let n=s[1],r;t==null?r=await new x().getVersion(n):r=await t.getVersion(n);let l=new a(r),i=e.split(";");for(let o=0;o<i.length;o++){let d=i[o];if(d.length<=0)continue;let c=d.split(","),f=c.shift()??"",g=l.getIDFClass(f).getFieldKeys(c.length),u=c.map((b,p)=>[g[p],b]),m=Object.fromEntries(u);l.addObject(f,m)}return l}getIDFClass(e){let t=e.toLowerCase();if(!(t in this.idfClasses)){let s=this.IDD[t];this.idfClasses[t]=new y(s)}return this.idfClasses[t]}addObject(e,t){let s=this.getIDFClass(e);s.idfObjects.push(new I(s,t))}getObjects(e,t){if(!(e.toLowerCase()in this.idfClasses))throw new RangeError(`'${e}' not in this idf!`);return this.getIDFClass(e).getObjectsFields(t)}toString(e=2,t=4,s=22){let n=" ".repeat(Math.floor(e)),r=" ".repeat(Math.floor(t)),l="";for(let[i,o]of Object.entries(this.idfClasses))for(let d of o.idfObjects)l+=d.toString();return l}};export{x as IDDManager,F as IDF};
